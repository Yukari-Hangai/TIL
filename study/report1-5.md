# 1月5日　　C++テキスト学習
#### ﾀｲﾋﾟﾝｸﾞ練習
- 1回目 3:59
- 5回目 3:56
&nbsp;  
&nbsp;  
## 右辺値参照
**1. 通常の参照と右辺値参照**
左辺値　⇒　変数や引数など値を代入できるもの  
右辺値　⇒　数値リテラル、関数の戻り値や関数形式の明示的な型変換など値を代入できない  
　通常の参照は左辺値でのみ初期化ができる。  
右辺値参照は通常の参照とは異なり右辺値への参照のみを格納できる機能。  
```
型&& 変数 = 右辺値;
```
　右辺値参照は右辺値でのみ初期化ができるが、左辺値では初期化できない。  
しかし、右辺値参照型の変数は左辺値である。参照はほかの参照型変数を参照できるが右辺値参照は  
他の右辺値参照型変数を参照することはできない。
```
int& a = 1; //エラー、通常の参照は右辺値1で初期化できない
int v;
int&& b = v; //エラー、右辺値参照は左辺値vで初期化できない
int&& c = b; //エラー、右辺値参照型変数bは左辺値なので右辺値参照cを初期化できない
int& d = b; //OK、右辺値参照型変数bは参照なので参照dを初期化できる
a = 10; //OK、参照aは左辺値なので右辺値10を代入できる
b = 10; //OK、右辺値参照bは左辺値なので右辺値10を代入できる
```
&nbsp;  
**2. 右辺値のアドレス**  
　右辺値参照には右辺値を参照できるだけでなく、値を代入することもできる。
```
int&& i = 1; //1への右辺値参照
i = 0; //Ok、iは左辺値である

if(1 == 0) //1 == 0となったのか...？
{
   ........
```
　左辺値の場合、オブジェクトが同じものであるかを調べるにはアドレス値を使って確認する。
では右辺値はどのようなアドレス値を持っているのか。
　実は右辺値のアドレスを取ろうとするとエラーになる。右辺値が有効なアドレスを持っていないことを表す。
右辺値は「メモリ上のどこかにある変数」ではない。
```
int* p = &0; //エラー、右辺値のアドレスは取れない
```
右辺値参照型変数は、左辺値であり代入できる先が必要。つまり何かしらのアドレスを持っている。  
実際に同じ右辺値から作られた異なる右辺値参照型変数のアドレスを確認すると下記のようになる。
``` 右辺値参照のアドレス.cpp
#include <iostream>

int main()
{
    int&& i = 0;
    int&& j = 0;

    std::cout << "&i : " << &i << std::endl;
    std::cout << "&j : " << &j << std::endl;
}
```
↓実行結果
```
&i : 000000F5A18FF924
&j : 000000F5A18FF964
```
　それぞれ異なったアドレスを持つことが確認できる。
つまり同じ右辺値を使った右辺値参照であっても、右辺値参照として参照するときは  
それぞれ別のオブジェクトが作られている。  
``` 冒頭のプログラム.cpp
#include <iostream>

int main()
{
    int&& i = 1; //1への右辺値参照
    i = 0; //Ok、iは左辺値である

    if(1 == 0) //1 == 0となったのか...？
    {
        std::cout << "1 == 0" << std::endl;
    }
    else
    {
        std::cout << "1 != 0" << std::endl;
    }
}
```
↓実行結果
```
1 != 0
```
&nbsp;  
**3. 右辺値参照のオーバーロード**  
　右辺値参照は通常の参照とは異なり、オーバーロードすることができる。
```参照と右辺値参照のオーバーロード.cpp
#include <iostream>

void show(int& v)
{
    std::cout << "参照:" << v << std::endl;
}

void show(int&& v) //右辺値参照で受け取るオーバーロード
{
    std::cout  << "右辺値参照:" << v << std::endl;
}

int main()
{
    int v = 1;
    show(v); //変数は左辺値
    show(42); //数値は右辺値
}
```
↓実行結果
```
参照:1
右辺値参照:42
```
  実引数に変数を渡した場合、変数は左辺値なので参照のオーバーロードが呼ばれるが、リテラルは右辺値なので  
右辺値参照のオーバーロードが呼ばれる。ごくまれに右辺値の場合（もしくはその逆の参照の場合）に高速な処理  
をすることができることがあるので右辺値参照でオーバーロードすることで効率のよいプログラムが書けることがある。
&nbsp;  
**3. ムーブコンストラクター**  
　コピーコンストラクターと似たようなコンストラクターとして、ムーブコンストラクターというものを定義できる。  
コピーコンストラクターはconst参照を受け取っていたのに対し、ムーブコンストラクターは右辺値参照を受け取るコンストラクター。  
　コンストラクターとムーブコンストラクターは、同一クラス上で両者を定義できるし、どちらだけにすることもできる。  
```
class クラス名
{
public:
    クラス名（クラス名&& 変数名); //ムーブコンストラクター
};
```
↓ムーブコンストラクター
```
#include <iostream>
#include <string>
#include <utility>

class person
{
	std::string m_name;
	int m_age;

	person(int age) : m_age{age}{}

public:
	person() : person{ -1 }{}
	person(std::string name, int age)
		: m_name{name}, m_age{age}{}

	person(person&& ohter); //ムーブコンストラクター

	const std::string& name() const { return m_name; }
	int age() const { return m_age; }
};

person::person(person&& other) //ムーブコンストラクター
	: m_name{ other.m_name }, m_age{ other.m_age }
{
	std::cout << "ムーブコンストラクター呼び出し" << std::endl;
}

int main()
{
	person alice{ "alice", 15 };

	person move{ std::move(alice) }; //ムーブコンストラクターで初期化

	std::cout << move.name() << std::endl;
	std::cout << move.age() << std::endl;
}
```
↓実行結果
```
ムーブコンストラクター呼び出し
alice
15
```
　std::move()関数は左辺値を強制的に右辺値として扱えるようにするヘルパー関数。変数aliceは右辺値ではないので  
そのまま渡してもムーブコンストラクターを呼び出せずにエラーとなる。そこでstd::move()関数で左辺値から右辺値参照へ  
変換するとムーブコンストラクターを呼び出すことができるようになる。
&nbsp;  
**4. コピーとムーブ**  
　コピーコンストラクターとムーブコンストラクターには明確な役割の違いがある。
　コピーは文字通り複製という意味で、元のインスタンスとメンバー変数がおなじになるように初期化する。ただし、メンバー変数が動的確保したポインターを持っていた場合、多重開放しないように新たにメモリ領域を動的確保して変数をコピーするのが一般的。ただ、メモリの動的確保はパフォーマンスにとても重大な影響を及ぼすことがあり、コピーをたくさん行うとプログラム全体の処理が重くなることがある。
　ムーブはコピーと異なり所有権の移動を行う。コンストラクターで動的確保されたメモリ領域はデストラクターで破棄されるため、オブジェクトの一部とみなすことができるが、実際にはインスタンスとは別のメモリ領域に置かれているものでありインスタンスの破棄とは直接的には関係しない。そのため、インスタンスの一部というよりもインスタンスがそのメモリを所有していると考えることができる。所有権の移動とは、その所有しているメモリ領域をほかのインスタンスに譲渡するという考え方になる。
　ムーブの方がコピーより処理が早く、メモリ領域の無駄も少ない。ムーブ元のインスタンスは、ムーブ後はメモリ領域の所有権を持っていないのでヌルポインターなどを代入してメモリ領域にアクセスできないようにするといい。
```#include <iostream>
#include <utility>

class home
{
	int* m_land; //土地

public:
	explicit home(std::size_t size)
		: m_land{new int[size]}{}

	~home() { delete[] m_land; }

	home(home&& other);

	int* land() const { return m_land; }
};

home::home(home&& other)
	: m_land{ other.m_land } //ムーブ元のポインターother.m_landをm_landにコピーする
{
	other.m_land = nullptr;//ムーブ元のポインターを空にする。これにより所有権はムーブ先のm_landになる。
}

int main()
{
	home A{ 100 };

	std::cout << "Aの土地のアドレス：" << A.land() << std::endl;

	home B{ std::move(A) };//Aは要らないのでstd::moveを使いムーブコンストラクターででAからBに所有権を移動

	std::cout << "Bの土地のアドレス：" << B.land() << std::endl;
	std::cout << "移動後のAの土地のアドレス：" << A.land() << std::endl;
}
```
↓実行結果
```
Aの土地のアドレス：000001CDF2D45DC0
Bの土地のアドレス：000001CDF2D45DC0
移動後のAの土地のアドレス：0000000000000000
```
　所有権の移動を含む一連の動作はムーブセマンティクスと呼ばれ標準ライブラリは、そのほとんどが対応している。ムーブセマンティクスはインスタンスを値で受け取る関数の呼び出しで見かける。引数として渡しているインスタンスを関数から戻ってきた後で使わない場合、引数として渡す場合にムーブするとコピーしないで関数にインスタンスを渡すことができる。
```
void some_function(home home); //値で受け取る関数

{
    home A;
    some_function(A);//コピーで渡す。この後もまだAを使う
    some_function(std::move(A)); //もうAは使わないのでムーブで渡す
}
```
&nbsp;  
&nbsp;  
**練習問題**  
1.右辺値参照を受け取る関数を定義し、何か変数を実引数にして呼び出してください。
↓解答
```

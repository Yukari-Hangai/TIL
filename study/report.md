# 12月27日　　C++テキスト学習
#### ﾀｲﾋﾟﾝｸﾞ練習
- 1回目 4:47
- 5回目 4:37
&nbsp;  
&nbsp;  
## 配列とポインター
**1. ポインターへの暗黙変換**  
配列は、ポインター型への暗黙変換ができる。  
配列にはたくさんの要素があるが、暗黙変換されるときには先頭の要素へのポインターとして変換される。  
```配列の暗黙変換.cpp
#include <iostream>

int main()
{
  int array[] = { 0, 1, 2, 3 };

  std::cout << "先頭のアドレス : " << &array[0] << std::endl;

  int* ptr = array;

  std::cout << "ポインター : " << ptr << std::endl;
  std::cout << "値 : " << *ptr << std::endl;
}
```
↓実行結果
``` 
先頭のアドレス : 00000009D40FF918
ポインター : 00000009D40FF918
値 : 0
```
ポインターが持つアドレスも、間接参照した値も配列の先頭を指していることがわかる。  
文字列リテラルも文字の配列なので、同様にポインターへの暗黙変換が可能。  
ただし、文字列リテラルは変更不可の配列なので、const修飾されたポインターとなる。  
```
const char* string = "string literal"; //文字列リテラルはconstな配列
```
※const : 変数などを変更不可とするための修飾子  
&nbsp;  
**2. 次のアドレス**  
配列をポインターに変換したときは先頭の要素のアドレスとなるが、先頭以外の要素にアクセスするときは配列の時と同じく添字演算子を使う。  
```先頭以外の要素.cpp
#include <iostream>

int main()
{
	int array[] = { 0, 1, 2, 3 };

	int* ptr = array;

	std::cout << ptr[0] << std::endl;
	std::cout << ptr[1] << std::endl;
	std::cout << ptr[2] << std::endl;
	std::cout << ptr[3] << std::endl;
}
```
↓実行結果
```
0
1
2
3
```
添字演算子は直接任意の要素にアクセスするが、ポインターのアドレスを使ってもアクセスできる。  
変数のアドレスは１を足すと次の要素のアドレスを、１を引くと前の要素のアドレスを指す。  
１以上を足しひきするとさらに次や前の要素のアドレスとなり、好きな要素のアドレスを入手できる。  
``` 先頭以外のアドレス.cpp
#include <iostream>

int main()
{
	int array[] = { 0, 1, 2, 3 };

	int* ptr = array;

	ptr += 2; //2番目の要素のアドレス
	std::cout << *ptr << std::endl;

	++ptr; //3番目の要素のアドレス
	std::cout << *ptr << std::endl;

	ptr -= 2; //1番目の要素のアドレス
	std::cout << *ptr << std::endl;

	--ptr; //0番目の要素のアドレス
	std::cout << *ptr << std::endl;
}
```
↓実行結果
```
2
3
1
0
```
